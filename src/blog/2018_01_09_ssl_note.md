# **HTTPS Note**

# PKI 系統

Public key 加密方法，典型代表是 RSA 演算法，透過亂數生成的一組對稱的
`Public Key` & `Private Key`，可以達到

加密(明文, Public Key) -> 只能透過 Private Key 解密
加密(明文, Private Key) -> 只能透過 Public Key 解密

進而完成安全性上所需的加解密/簽章等需求。

## 在憑證系統的 trust chain

對於一張憑證會有所謂的(PS. 括號內為 java keytool 所使用的名詞)

- Subject(擁有者): 指此憑證是提供給何人
- Issuer(發出者): 證明此憑證的人是誰

在這邊的人員表示使用了 LDAP 的表示法，也就是一串由逗號分格的 XX=XXX 的格式，例如：

`C=TW, O=TAIWAN-CA, OU=Root CA, CN=TWCA Root Certification Authority`

在憑證系統中採用了 trust chain 的方式，假設
A 說我相信 B，B 說我相信 C，C 說我相信 D，
所以你只需要相信 A，就可以代表你相信了 A,B,C,D

而通常簽發憑證的機構會稱他是 CA (Certifcation Authority)，最上層的就叫 Root CA。
在OS和瀏覽器之中預設就有內建一定數量的 Root CA，也就是這樣平時瀏覽網頁時才可以用以確認所瀏覽的網站是否可相信。

# 相關的檔案格式

- 單一張憑證的儲存

DER - 二進位的憑證資料，打開通常...不!你不會看到任何你認識的東西XD

PEM - 將 DER 格式用 Base64 編碼再在前後加上 `-----BEGIN CERTIFICATE-----` 和 `-----END CERTIFICATE-----`，類似如下：

```
-----BEGIN CERTIFICATE-----
MIIDezCCAmOgAwIBAgIBATANBgkqhkiG9w0BAQUFADBfMQswCQYDVQQGEwJUVzES
MBAGA1UECgwJVEFJV0FOLUNBMRAwDgYDVQQLDAdSb290IENBMSowKAYDVQQDDCFU
V0NBIFJvb3QgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMDgwODI4MDcyNDMz
                            ......
-----END CERTIFICATE-----

```

CER, CRT, DER - 這幾個副檔名，**通常**使用的是 `DER` 格式，但在裡面裝 `PEM` 格式也很常見，換言之就是打開看看 或用 openssl 指令直接檢查最快

```
openssl x509 -in [XXX].cer -text
```

輸出的格式大略如下：

```
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 1 (0x1)
    Signature Algorithm: sha1WithRSAEncryption
        Issuer: C=TW, O=TAIWAN-CA, OU=Root CA, CN=TWCA Root Certification Authority
        Validity
            Not Before: Aug 28 07:24:33 2008 GMT
            Not After : Dec 31 15:59:59 2030 GMT
        Subject: C=TW, O=TAIWAN-CA, OU=Root CA, CN=TWCA Global Root CA
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:b0:7e:72:b8:a4:03:94:e6:a7:de:09:38:91:4a:
                    ...
                Exponent: 65537 (0x10001)
    Signature Algorithm: sha1WithRSAEncryption
         3c:d5:77:3d:da:df:89:ba:87:0c:08:54:6a:20:50:92:be:b0:
         ...
```

注意其中的 `Subject` 和 `Issuer`

NET - **待補**


- 以下是金鑰儲存庫 (可以儲存多張憑證 & Private Key)

P12,PFX - P12(PKCS#12),PFX(P12的下一版) 都是憑證的儲存庫 (搭配 `openssl pkcs12`) 指令操作

JKS - Java 使用的儲存庫 (搭配 `keytool` 指令操作)

- 會這樣用但沒有什麼標準

KEY - Private Key，通常用 `PEM` 格式，可用以下指令檢查

```
openssl rsa -in [XXX].key -text
或
openssl rsa -in [XXX].key -check
```

# HTTPS 概要

- 版本演進: SSL 1.0 -> 2.0(1995) -> 3.0(1996) -> TLS 1.0(1999) -> 1.1(2006) -> 1.2 (2008)
- SSL 3.0 在2014年被發現設計缺陷，已被建議停用
- SSL 3.0 和 TLS 1.0 差異非常微小
- TLS 1.2 刪除了對 SSL 支援 (印像中是說 SSL 3.0 與 TLS 1.2 無法同時啟用，來源待查)

- SSL 憑證目前主要基於 X.509，使用OpenPGP的憑證正在研議中

## HTTPS cipher suite

在 HTTPS 中加密使用的組合，共有以下選項，這些選項會在 HTTPS 初始化時，
由 Client 送出支援的演算法，並由 Server 決定實際上使用的 cipher suite

1. Key exchange(Kx)
2. Authentication(Au)
3. Block cipher(Enc)
4. HMAC(Mac)

一個有效的 Cipher 名稱通常像這樣 `ECDHE-RSA-AES256-GCM-SHA384`，表示在這個 Cipher suite 中：

1. Key exchange(Kx): **ECDH**
2. Authentication(Au): **RSA**
3. Block cipher(Enc): **AESGCM(256)**
4. HMAC(Mac): **AEAD** (表示[不需要實際MAC](https://security.stackexchange.com/questions/57423/openssl-ciphers-sha384-and-aead)，這裡有點技術細節可先忽略)

- [Mozilla 提供的建議 Cipher Suite 列表][mozilla_cipher_suites]

## 下載網站的 certificate

https://superuser.com/questions/97201/how-to-save-a-remote-server-ssl-certificate-locally-as-a-file

使用指令（但目前不支援透過 proxy 取得）

```
openssl s_client -connect {HOSTNAME}:{PORT} -showcerts
```

## 列出伺服器端支援的 Cipher Suite (bash script)

https://superuser.com/questions/109213/how-do-i-list-the-ssl-tls-cipher-suites-a-particular-website-offers

```
#!/usr/bin/env bash

# OpenSSL requires the port number.
SERVER=$1
DELAY=1
ciphers=$(openssl ciphers 'ALL:eNULL' | sed -e 's/:/ /g')

echo Obtaining cipher list from $(openssl version).

for cipher in ${ciphers[@]}
do
echo -n Testing $cipher...
result=$(echo -n | openssl s_client -cipher "$cipher" -connect $SERVER 2>&1)
if [[ "$result" =~ ":error:" ]] ; then
  error=$(echo -n $result | cut -d':' -f6)
  echo NO \($error\)
else
  if [[ "$result" =~ "Cipher is ${cipher}" || "$result" =~ "Cipher    :" ]] ; then
    echo YES
  else
    echo UNKNOWN RESPONSE
    echo $result
  fi
fi
sleep $DELAY
done
```

## 檢查目前瀏覽器支援的 Cipher Suite

https://cc.dcsec.uni-hannover.de/

# Java 的 HTTPS 相關

## JBoss HTTPS

- jeap 限制使用的 https 版本
https://stackoverflow.com/questions/23668951/how-to-change-ssl-version-for-https-connections-in-jboss-eap-6-1

## HTTPS Client Certification

**待補**

## Java 的 Certificate 匯入相關

- TODO
https://stackoverflow.com/questions/4325263/how-to-import-a-cer-certificate-into-a-java-keystore

## JDK 預設信任憑證位置

- Java 預設的信任憑證位置在 `{jdk_home}/jre/lib/security/cacerts`

    - MacOS 的位置 `/Library/Java/JavaVirtualMachines/{java version}/Contents/Home/jre/lib/security/cacerts`

可以透過啟動時的參數修改

```
-Djavax.net.ssl.keyStore=keystore.jks
-Djavax.net.ssl.trustStrore=cacerts.jks
-Djavax.net.ssl.keyStorePassword=changeit
```


# 產生、簽屬、套用 HTTPS 憑證

以下以 **jboss** 的情況來說明 (因為本次遇到的是 jboss  XD)

大概需要以下步驟

1. 產生伺服器憑證及私鑰
2. 產生憑證請求檔(CSR)
3. 將憑證請求檔送給憑證單位簽屬
4. 將簽屬完成的結果合併至憑證儲存庫
5. 將憑證儲存庫設定給伺服器啟動使用

## 1. 產生伺服器憑證

產生憑證及 Private Key

## 2. 產生憑證請求檔(CSR)

產生伺服器的定義資料，重點是要填入伺服器的 domain name

## 3. 將憑證請求檔送給憑證單位簽屬

將產生的 CSR 檔案送給憑證單位做簽屬，

取回的憑證資料，通常會包含 2~多個憑證檔案，至少應該有一個伺服器憑證和一個根慼證(Root CA)

# 參考文件

- [Wiki: X509][wiki_x509]

[wiki_x509]: https://en.wikipedia.org/wiki/X.509
[mozilla_cipher_suites]: https://wiki.mozilla.org/Security/Server_Side_TLS
